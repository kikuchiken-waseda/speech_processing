===========================================
型無しラムダ計算（Untyped Lambda Calculus, ULC）
===========================================

1. 定義と背景
=============

ラムダ計算は、関数適用と関数抽象のみで記述される計算体系であり、1930年代にアロンゾ・チャーチによって形式化された。
「型無し」ラムダ計算は、ラムダ計算の基本形であり、変数や関数の型の制限が一切存在しない。そのため、あらゆる項を自由に適用することができるが、
一方で意味的な誤用や停止しない項（無限ループ）も記述可能である。

本体系は、チューリングマシンと同等の表現力（チューリング完全性）を持ち、関数型プログラミング言語や形式意味論の基礎理論として重要である。

2. 構文（Syntax）
================

ラムダ計算における構文は、項（term）を中心に以下のように定義される。

.. code-block:: bnf

   <term>         ::= <abstraction>
               |  <application>

   <abstraction>  ::= "λ" <variable> "." <term>

   <application>  ::= <application> <atom>
               |  <atom>

   <atom>         ::= <variable>
               |  "(" <term> ")"

   <variable>     ::= <identifier>

- ``<term>`` は、全てのラムダ式の構文的な基底である。
- ``<abstraction>`` は関数抽象（ラムダ抽象）を表す。構文 ``λx.M`` において ``x`` は束縛変数、``M`` は関数本体。
- ``<application>`` は関数適用を表し、関数 ``M`` に引数 ``N`` を適用する ``M N`` の形。
- ``<atom>`` は関数適用の最小単位であり、変数または括弧付き項。
- ``<variable>`` はラムダ計算における変数を表す終端記号であり、通常は識別子 ``x``, ``y``, ``z`` などで表現される。
- ``<identifier>`` は任意の変数集合から選ばれる文字列であると仮定する。ラムダ計算では具体的な字句形式を問題にせず、変数の衝突を α変換により処理する。

**構文上の結合規則と優先順位**

関数適用は左結合である。すなわち:

.. math::

     M N P ≡ ((M N) P)

関数抽象は右結合である。すなわち

.. math::

     λx.λy.M ≡ λx.(λy.M)

**備考**

- 括弧 ``(...)`` はグルーピングに使用され、適用の結合順や抽象のスコープを明示するために任意で導入される。
- 関数抽象と関数適用の両方を構文的に許すため、``<application>`` を ``<term>`` に再帰させる形で構文木の構造を定義している

3. 意味論（Semantics）
======================

ラムダ計算の意味論は、項の等価性と簡約規則によって定義される。
このセクションでは、代表的な変換・簡約規則である **α変換**、**β簡約**、**η変換** について述べる。

3.1 α変換（alpha conversion）
----------------------------

**α変換** は、ラムダ抽象における束縛変数の名前変更を許容する等価変換である。

.. math::

   \lambda x. M \;\equiv_\alpha\; \lambda y. M[x := y] 
   \quad \text{（ただし } y \notin \mathrm{FV}(M) \text{）}

ここで :math:`M[x := y]` は、 **構文的代入（substitution）** を意味する。
すなわち、項 :math:`M` において自由に現れる変数 :math:`x` を、変数 :math:`y` に構文的に置き換えた項を表す。
ただし、新しい変数 :math:`y` は :math:`M` に自由変数として現れてはならない（:math:`y \notin \mathrm{FV}(M)`）。

これは、束縛変数の名前は構文上のラベルにすぎず、項の意味には影響を与えないことを示している。

3.2 β簡約（beta reduction）
----------------------------

**β簡約** は、関数適用の評価規則であり、ラムダ計算における「実行」に相当する。

.. math::

   (\lambda x. M) \; N \;\rightarrow_\beta\; M[x := N]

ここで :math:`M[x := N]` は、 **構文的代入（substitution）** を意味する。
すなわち、項 :math:`M` において自由に現れる変数 :math:`x` を、項 :math:`N` に構文的に置き換えた項である。

この簡約規則は、「関数 :math:`\lambda x. M` に引数 :math:`N` を適用すると、:math:`x` が :math:`N` に構文的に代入された項が得られる」ことを意味する。
この操作は項の内部にも再帰的に適用可能であり、評価（簡約）を進行させる。

3.3 η変換（eta conversion）
---------------------------

**η変換** は、関数の外延的同値性（extensionality）を表す変換である。

.. math::

   \lambda x. (M\;x) \;\equiv_\eta\; M 
   \quad \text{（ただし } x \notin \mathrm{FV}(M) \text{）}

これは、「任意の引数 :math:`x` に対して :math:`M x` を返す関数は、:math:`M` 自体と意味的に同一である」ことを意味する。
つまり、関数の振る舞いがすべての入力において等しいなら、それらの関数は同一視できる。

4. 自由変数と束縛変数
======================

変数には、 **束縛変数** （bound variable）と **自由変数** （free variable）がある。

- 束縛変数：:math:`\lambda x.M` における :math:`x` は、:math:`M` の内部で束縛されている。
- 自由変数：スコープ内で束縛されていない変数。

自由変数集合 :math:`\mathrm{FV}(M)` は以下のように定義される：

.. math::

   \mathrm{FV}(x) &= \{x\} \\
   \mathrm{FV}(M \; N) &= \mathrm{FV}(M) \cup \mathrm{FV}(N) \\
   \mathrm{FV}(\lambda x. M) &= \mathrm{FV}(M) \setminus \{x\}

束縛変数の名前は **α変換** により変更可能であるが、自由変数には影響しない。

5. 評価戦略（Evaluation Strategy）
==================================

:math:`\beta` 簡約は複数の順序で適用できるため、**評価戦略** が必要となる。

- **正規順（normal order）**：
  外側から左端の関数適用を優先する。
  正規形が存在する場合、必ずそこに到達する。

- **適用順（applicative order）**：
  引数を先に簡約し、完全な関数適用を構成してから評価する。
  一般的な :math:`\text{call-by-value}` に相当する。

- **遅延評価（lazy evaluation）**：
  正規順と同じく、必要な引数のみを評価する。

**注意**：正規順は停止性を保つが、評価効率の面では最適ではない。

6. 表現力（Expressiveness）
===========================

型無しラムダ計算は、あらゆるデータや演算を関数として表現可能である。
以下に代表的なエンコーディング（Church encoding）を示す。

6.1 ブール値（Church Encoding）
------------------------------

.. math::

   \mathrm{TRUE}  &= \lambda t.\lambda f. \; t \\
   \mathrm{FALSE} &= \lambda t.\lambda f. \; f

条件分岐は以下のように定義できる：

.. math::

   \mathrm{IF} = \lambda b.\lambda x.\lambda y. \; b \; x \; y

6.2 自然数（Church Numerals）
----------------------------

.. math::

   0 &= \lambda f.\lambda x. \; x \\
   1 &= \lambda f.\lambda x. \; f \; x \\
   2 &= \lambda f.\lambda x. \; f (f \; x) \\
   n &= \lambda f.\lambda x. \; \text{f を n 回適用}

6.3 基本演算
------------

.. math::

   \mathrm{SUCC} &= \lambda n.\lambda f.\lambda x. \; f (n \; f \; x) \\
   \mathrm{ADD}  &= \lambda m.\lambda n.\lambda f.\lambda x. \; m \; f \; (n \; f \; x) \\
   \mathrm{MUL}  &= \lambda m.\lambda n.\lambda f. \; m \; (n \; f)

7. 再帰（Yコンビネータ）
========================

型無しラムダ計算には **名前付き関数定義** が存在しないが、**不動点コンビネータ（fixed-point combinator）** によって
自己再帰関数の定義が可能となる。

Yコンビネータは次のように定義される：

.. math::

   Y = \lambda f.(\lambda x. f (x \; x)) (\lambda x. f (x \; x))

この式は任意の関数 :math:`f` に対して、:math:`f` 自身を引数として適用することで自己再帰を可能にする。

たとえば階乗関数などの定義に使用できる。

8. 性質
=======

- **チューリング完全**：任意の計算可能関数を表現可能。
- **正規形の存在性は保証されない**：以下の項は簡約が無限に続き、正規形を持たない：

  .. math::

    \Omega = (\lambda x. x \; x)(\lambda x. x \; x)

- **安全性が保証されない**：型が存在しないため、意味的に不適切な項も記述可能。
  例：

  .. math::

    \mathrm{TRUE} \; 1 \; 2 \; 3

- **構文上は最小だが、意味論上は非常に強力**：3つの構文要素（変数・抽象・適用）だけで、任意の計算を定義できる。


9. 応用と限界
=============

.. list-table:: 応用と限界
   :widths: 20 80
   :header-rows: 1

   * - 項目
     - 内容
   * - 応用
     - 計算理論、関数型言語の形式的基盤、形式意味論、プログラム変換、証明支援系など
   * - 限界
     - 型安全性がない、プログラムの意味が曖昧、評価の停止性が保証されない

